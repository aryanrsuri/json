diff --git a/.gitignore b/.gitignore
index 5903299..c36810c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,2 +1,3 @@
-zig-cache/
-zig-out
+zig-cache/*
+zig-out/*
+.zig-cache/*
diff --git a/README b/README.md
similarity index 50%
rename from README
rename to README.md
index 16ee195..ff75916 100644
--- a/README
+++ b/README.md
@@ -1,7 +1,12 @@
-Implementing JSON (de)serialising and tokeniser in Zig
+## Implementing JSON (de)serialising and tokeniser in Zig
 
 Since this project is more about learning Zig, I will adding more 
 structure to the patterns, things that might not be most optimal for a 
 prod ready Json serialising library.
 
 Look into ./CHANGELOG for better and more information about the project.
+
+## TODO
+
+Remove the Token { .ch: []const u8} type, since there is no need to hold those literals
+They really just mark the stack structure which is handleled by the state/other tokens
diff --git a/build.zig b/build.zig
index 4b5049d..995ce99 100644
--- a/build.zig
+++ b/build.zig
@@ -19,7 +19,7 @@ pub fn build(b: *std.Build) void {
         .name = "json",
         // In this case the main source file is merely a path, however, in more
         // complicated build scripts, this could be a generated file.
-        .root_source_file = .{ .path = "src/main.zig" },
+        .root_source_file = b.path("src/main.zig"),
         .target = target,
         .optimize = optimize,
     });
@@ -55,7 +55,7 @@ pub fn build(b: *std.Build) void {
     // Creates a step for unit testing. This only builds the test executable
     // but does not run it.
     const unit_tests = b.addTest(.{
-        .root_source_file = .{ .path = "src/main.zig" },
+        .root_source_file = b.path("src/main.zig"),
         .target = target,
         .optimize = optimize,
     });
diff --git a/e.patch b/e.patch
new file mode 100644
index 0000000..c45de17
--- /dev/null
+++ b/e.patch
@@ -0,0 +1,88 @@
+diff --git a/.gitignore b/.gitignore
+index 5903299..c36810c 100644
+--- a/.gitignore
++++ b/.gitignore
+@@ -1,2 +1,3 @@
+-zig-cache/
+-zig-out
++zig-cache/*
++zig-out/*
++.zig-cache/*
+diff --git a/build.zig b/build.zig
+index 4b5049d..995ce99 100644
+--- a/build.zig
++++ b/build.zig
+@@ -19,7 +19,7 @@ pub fn build(b: *std.Build) void {
+         .name = "json",
+         // In this case the main source file is merely a path, however, in more
+         // complicated build scripts, this could be a generated file.
+-        .root_source_file = .{ .path = "src/main.zig" },
++        .root_source_file = b.path("src/main.zig"),
+         .target = target,
+         .optimize = optimize,
+     });
+@@ -55,7 +55,7 @@ pub fn build(b: *std.Build) void {
+     // Creates a step for unit testing. This only builds the test executable
+     // but does not run it.
+     const unit_tests = b.addTest(.{
+-        .root_source_file = .{ .path = "src/main.zig" },
++        .root_source_file = b.path("src/main.zig"),
+         .target = target,
+         .optimize = optimize,
+     });
+diff --git a/src/json.zig b/src/json.zig
+index 140c714..212e6c2 100644
+--- a/src/json.zig
++++ b/src/json.zig
+@@ -56,7 +56,7 @@ pub const Scanner = struct {
+ 
+     pub fn read_value(self: *@This()) []const u8 {
+         const value_start = self.cursor;
+-        while (std.ascii.isAlphanumeric(self.buffer[self.cursor])) {
++        while (std.ascii.isAlphanumeric(self.buffer[self.cursor]) or self.buffer[self.cursor] == '_' or self.buffer[self.cursor] == ' ' or self.buffer[self.cursor] == '-') {
+             self.read();
+         }
+         return self.buffer[value_start..self.cursor];
+diff --git a/src/main.zig b/src/main.zig
+index c8a3f67..bb979dd 100644
+--- a/src/main.zig
++++ b/src/main.zig
+@@ -1,24 +1,18 @@
+ const std = @import("std");
++const Scanner = @import("json.zig").Scanner;
+ 
+ pub fn main() !void {
+-    // Prints to stderr (it's a shortcut based on `std.io.getStdErr()`)
+-    std.debug.print("All your {s} are belong to us.\n", .{"codebase"});
+-
+-    // stdout is for the actual output of your application, for example if you
+-    // are implementing gzip, then only the compressed bytes should be sent to
+-    // stdout, not any debugging messages.
+-    const stdout_file = std.io.getStdOut().writer();
+-    var bw = std.io.bufferedWriter(stdout_file);
+-    const stdout = bw.writer();
+-
+-    try stdout.print("Run `zig build test` to run the tests.\n", .{});
+-
+-    try bw.flush(); // don't forget to flush!
+-}
+-
+-test "simple test" {
+-    var list = std.ArrayList(i32).init(std.testing.allocator);
+-    defer list.deinit(); // try commenting this out and see if zig detects the memory leak!
+-    try list.append(42);
+-    try std.testing.expectEqual(@as(i32, 42), list.pop());
++    const file =
++        \\{"this": "value", "number": 100, "array": [1,2,3], "array of strings": ["1","2"]}
++    ;
++    // const f =
++    //     \\{"this":"is", "that": 400, "things": [1,2,3]}
++    // ;
++    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
++    const allocator = gpa.allocator();
++    var s = Scanner.init(allocator, file);
++    while (s.state != .end_of_document) {
++        const v = try s.next();
++        std.debug.print("Token is {any}\n", .{v});
++    }
+ }
diff --git a/patches/test.patch b/patches/test.patch
new file mode 100644
index 0000000..e69de29
diff --git a/src/json.zig b/src/json.zig
index 140c714..4999415 100644
--- a/src/json.zig
+++ b/src/json.zig
@@ -56,7 +56,7 @@ pub const Scanner = struct {
 
     pub fn read_value(self: *@This()) []const u8 {
         const value_start = self.cursor;
-        while (std.ascii.isAlphanumeric(self.buffer[self.cursor])) {
+        while (std.ascii.isAlphanumeric(self.buffer[self.cursor]) or self.buffer[self.cursor] == '_' or self.buffer[self.cursor] == ' ' or self.buffer[self.cursor] == '-') {
             self.read();
         }
         return self.buffer[value_start..self.cursor];
@@ -97,7 +97,7 @@ pub const Scanner = struct {
             .string => {
                 switch (self.buffer[self.cursor]) {
                     '"' => self.state = .post_value,
-                    'a'...'z', 'A'...'Z', '_', '-' => return .{ .string = self.read_value() },
+                    '0'...'9', 'a'...'z', 'A'...'Z', '_', '-' => return .{ .string = self.read_value() },
                     else => return error.SyntaxError,
                 }
             },
diff --git a/src/main.zig b/src/main.zig
index c8a3f67..bb979dd 100644
--- a/src/main.zig
+++ b/src/main.zig
@@ -1,24 +1,18 @@
 const std = @import("std");
+const Scanner = @import("json.zig").Scanner;
 
 pub fn main() !void {
-    // Prints to stderr (it's a shortcut based on `std.io.getStdErr()`)
-    std.debug.print("All your {s} are belong to us.\n", .{"codebase"});
-
-    // stdout is for the actual output of your application, for example if you
-    // are implementing gzip, then only the compressed bytes should be sent to
-    // stdout, not any debugging messages.
-    const stdout_file = std.io.getStdOut().writer();
-    var bw = std.io.bufferedWriter(stdout_file);
-    const stdout = bw.writer();
-
-    try stdout.print("Run `zig build test` to run the tests.\n", .{});
-
-    try bw.flush(); // don't forget to flush!
-}
-
-test "simple test" {
-    var list = std.ArrayList(i32).init(std.testing.allocator);
-    defer list.deinit(); // try commenting this out and see if zig detects the memory leak!
-    try list.append(42);
-    try std.testing.expectEqual(@as(i32, 42), list.pop());
+    const file =
+        \\{"this": "value", "number": 100, "array": [1,2,3], "array of strings": ["1","2"]}
+    ;
+    // const f =
+    //     \\{"this":"is", "that": 400, "things": [1,2,3]}
+    // ;
+    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
+    const allocator = gpa.allocator();
+    var s = Scanner.init(allocator, file);
+    while (s.state != .end_of_document) {
+        const v = try s.next();
+        std.debug.print("Token is {any}\n", .{v});
+    }
 }
